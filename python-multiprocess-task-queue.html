<!DOCTYPE html>
<html lang="en">
<head>
    <title>Alice/Development Notes &mdash; A Python multi-process task queue</title>
    <meta charset="utf-8"/>
    <link rel="stylesheet" type="text/css" href="https://aliceh75.github.io/theme/css/style.css"/>
</head>

<body>
    <div id="container">
        <div id="header">
                <div id="site-title"><a href="https://aliceh75.github.io">Alice/Development Notes</a></div>
        </div>

        <div id="contents">
    <div class="post">
        <div class="entry-meta">
            <div class="date">Fri 04 July 2014</div>
            <div class="author">By Alice Heaton</div>
                <div class="tag-list">
                        <a href="https://aliceh75.github.io/tag/python" rel="tag">#python</a>
                </div>
        </div>
        <div class="entry-main">
            <h1 class="entry-title">
                <a href="https://aliceh75.github.io/python-multiprocess-task-queue" title="A Python multi-process task queue"
                   rel="bookmark">A Python multi-process task queue</a>
            </h1>
            <div class="entry-content">
                  <h2>Overview</h2>
<p>I was implementing a service (in Python) that enqueues and run specific tasks. <a href="http://queues.io/">There are plenty of task queue managers out there</a>, but they all require an external service - either the whole stack is external, or they are Python libraries but require an external service to store the queue (such as <a href="http://redis.io/">redis</a>).</p>
<p>My needs being simple, I searched online and found a number of simple solutions based on Pythons' <a href="https://docs.python.org/2/library/multiprocessing.html">multiprocessing</a> and decided to start from those to implement a simple solution.</p>
<p>As my solution builds on the existing simple solutions I found, I thought I would share it here.</p>
<h2>Simple approach</h2>
<p>The basic approach using multiprocessing (the one I found explained on various sites) looks something like this:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">multiprocessing</span>

<span class="k">def</span> <span class="nf">_worker</span><span class="p">(</span><span class="n">queue</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="n">task</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">TaskQueue</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workers</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_queue</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">workers</span><span class="p">,</span> <span class="n">_worker</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queue</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
</pre></div>


<p>And that's it - it is really simple to implement. The tasks need to be an object with a <code>run</code> method, for instance:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyTask</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
        <span class="c1"># This is run on the main process, when the task is crated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param</span> <span class="o">=</span> <span class="n">param</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># This is run on the child process. We can do something with param</span>
        <span class="c1"># (note that we must be able to pickle param)</span>
        <span class="k">pass</span>
</pre></div>


<h2>Managing the workers</h2>
<p>There are a number of things I wanted that do not work with this approach however:</p>
<ul>
<li>I wanted workers to stop after a certain amount of requests;</li>
<li>I wanted to be able to terminate the workers.</li>
</ul>
<p>To implement this with the previous approach of using a <code>Queue</code> requires a bit of work. The workers would have to have a loop to exit after a certain number of requests; we'd have to be able to instruct the workers to terminate, and we would need a separate thread to restart workers that have stopped.</p>
<p>Instead we can use <code>multiprocessing.Pool</code> - it allows us to specify the number of requests served by each worker by specifying <code>maxtasksperchild</code>. Our workers cannot be an infinite loop anymore however, so we need another way to send parameters to the workers. Calling <code>apply_async</code> for each task does just that - and <code>multiprocessing.Pool</code> handles the queueing for us. Arguably this approach is actually simpler than the previous one - though not one I found online.</p>
<p><code>Pool.close</code> and <code>Pool.terminate</code> can be used to write a <code>terminate</code> method. So the implementation would now be:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_worker</span><span class="p">(</span><span class="n">task</span><span class="p">):</span>
    <span class="n">task</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
    <span class="k">return</span> <span class="bp">True</span>


<span class="k">class</span> <span class="nc">TaskQueue</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker_count</span><span class="p">,</span> <span class="n">requests_per_worker</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">worker_count</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">requests_per_worker</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">_worker</span><span class="p">,</span> <span class="p">(</span><span class="n">task</span><span class="p">,))</span>

<span class="k">def</span> <span class="nf">terminate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>


<p>Note the implementation of terminate here is a bit naive. We don't have a way to tell when a worker has stopped, so <code>terminate</code> will sleep even if all the tasks closed immediately. We will improve on this later on.</p>
<h2>Tracking operations</h2>
<p>We'd like to be able to tell how many tasks are in the queue, and how many have been processed altogether. For this we'll use <code>apply_async</code>'s return object which tells us when a task has finished (as well as it's return value, though we don't care about this in the current implementation). This will also allow us to implement <code>terminate</code> properly. The implementation is straightforward - though I'll include it here for completeness.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TaskQueue</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker_count</span><span class="p">,</span> <span class="n">requests_per_worker</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">worker_count</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">requests_per_worker</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tasks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_processed_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_open</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">_worker</span><span class="p">,</span> <span class="p">(</span><span class="n">task</span><span class="p">,))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="c1"># Call flush here to ensure we clean up even if length/processed are never called.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flush</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flush</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tasks</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">processed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flush</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processed_count</span>

    <span class="k">def</span> <span class="nf">terminate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flush</span><span class="p">()</span>
        <span class="n">time_waited</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tasks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">time_waited</span> <span class="o">&lt;</span> <span class="n">timeout</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="n">time_waited</span> <span class="o">+=</span> <span class="mf">0.1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flush</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">new_tasks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tasks</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">t</span><span class="o">.</span><span class="n">ready</span><span class="p">():</span>
                <span class="n">new_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_processed_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tasks</span> <span class="o">=</span> <span class="n">new_tasks</span>
</pre></div>


<p>Note that <code>length</code> returns the number of items that are either in the queue, or currently being processed. This is fine for my use case - to make the distinction between the queues we'd have to track (using a <code>Queue</code>) when each worker actually starts processing the task.</p>
<h2>Logging</h2>
<p>We want to log what's happening - when workers start, when they are killed, when they start and finish processing tasks. We can't use the normal logger classes as they do not work across processes - instead we need to use the logger provided by <code>multiprocessing.get_logger</code>. Setting the log level to <code>INFO</code> will ensure <code>multiprocessing</code> logs when the workers start and end, and we can log when tasks start and end ourselves in <code>_worker</code>:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_worker</span><span class="p">(</span><span class="n">task</span><span class="p">):</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Worker {} failed to get task description. {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">format_exc</span><span class="p">()))</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="s1">&#39;(unknown)&#39;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Worker {} processing task {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">desc</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">task</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Worker {} failed task {}. {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">format_exc</span><span class="p">()))</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Worker {} done with task {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
    <span class="k">return</span> <span class="bp">True</span>
</pre></div>


<p>Note that we use <code>format_exc</code> (import it from <code>traceback</code>) to display the full backtrace of any exception that makes it that far - there is nothing above us, and the exception will get lost if we don't display it.</p>
<p>If you are embedding this in a larger application, you may not have the opportunity to change the application's logger object to use the multiprocessing one (so that all logs go to the same place). Assuming you can set the log handler used by the application you can deal with this issue by implementing a log handler which forwards logs to the multiprocessing logger:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>


<span class="k">class</span> <span class="nc">MultiprocessingLogHandler</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">Handler</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A log handler that forwards messages to the multiprocessing logger.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">emit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="n">logger</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">handle</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
</pre></div>


<p>You can then replace the application's log handler with an instance of this one. For example in Flask:</p>
<div class="highlight"><pre><span></span><span class="c1"># Set up the multiprocessing logger</span>
<span class="n">m_logger</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span>
<span class="n">m_logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
<span class="n">m_logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">login</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">))</span>

<span class="c1"># Remove any existing log handlers in the application handler</span>
<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">handlers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">removeHandler</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">handlers</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="c1"># And add our custom handler to the application logger</span>
<span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">MultiprocessingLogHandler</span><span class="p">())</span>
</pre></div>


<h2>Testing</h2>
<p>I have written a test suite (using nosetest) for this. It is not based on the exact version of the code described here, but should give you a good head start for writing tests for your own implementation. You can find it on <a href="https://github.com/NaturalHistoryMuseum/ckanpackager/blob/master/ckanpackager/tests/queue.py">GitHub</a>.</p>
<h2>Conclusion</h2>
<p>If your requirements are simple enough then it's easier to use Python built-in libraries to implement a queue in this way. Of course it lacks many features of a more full fledged solution: email error reporting, queue persistence, scheduling, etc. If these are important to you, then you should probably use an existing solution!</p>
            </div>
        </div>
    </div>
        </div>

        <div id="footer">
            <p>Alice online: <a href="http://github.com/aliceh75">GitHub</a> <a href="https://twitter.com/aliceheaton75">Twitter</a></p>
            <p>Site generated by <a href="http://pelican.readthedocs.org">Pelican</a>, theme loosely based on <a href="https://github.com/tbunnyman/pelican-chunk">Chunk</a></p>
            <p>All content by Alice Heaton, licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
               <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
            </p>
        </div>
    </div>
</body>
</html>