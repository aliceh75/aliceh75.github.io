<!DOCTYPE html>
<html lang="en">
<head>
    <title>Alice/Development Notes &mdash; Setting up an Prosody server in Debian Jessie</title>
    <meta charset="utf-8"/>
    <link rel="stylesheet" type="text/css" href="http://aliceh75.github.io/theme/css/style.css"/>
</head>

<body>
    <div id="container">
        <div id="header">
                <div id="site-title"><a href="http://aliceh75.github.io">Alice/Development Notes</a></div>
        </div>

        <div id="contents">
    <div class="post">
        <div class="entry-meta">
            <div class="date">Sun 05 March 2017</div>
            <div class="author">By Alice Heaton</div>
                <div class="tag-list">
                        <a href="http://aliceh75.github.io/tag/prosody" rel="tag">#prosody</a>
                </div>
        </div>
        <div class="entry-main">
            <h1 class="entry-title">
                <a href="http://aliceh75.github.io/drafts/setting-up-prosody-server-in-debian-jessie" title="Setting up an Prosody server in Debian Jessie"
                   rel="bookmark">Setting up an Prosody server in Debian Jessie</a>
            </h1>
            <div class="entry-content">
                  <p>I wanted to set up a small chat/messenging server (with modern features such as multi user rooms, file uploads and offline messages) for a small group of people. After some research I decided to go for <a href="http://prosody.im">prosody</a>, and here I describe how I set it up for my specific use case on <a href="https://wiki.debian.org/DebianJessie">Debian Jessie</a>.</p>
<p>The server is aimed at a small group of people - it does not need to be able to connect with other servers, and it does not need to support more than a few dozen users.</p>
<p>My specific requirements were:</p>
<ul>
<li>Exists as a Debian Jessie package - this ensures I get security updates as part of Debian updates and I don't need to handle it separately;</li>
<li>Handles multi user chat rooms (<a href="http://xmpp.org/extensions/xep-0045.html">XEP 0045</a>) - this means users can create chatrooms, and are not limited to one-to-one chats;</li>
<li>Handles http file uploads (<a href="https://xmpp.org/extensions/xep-0363.html">XEP_0363</a>) - this means (amongst other things) that users can send each other files in chat rooms;</li>
</ul>
<p>And bonuses:</p>
<ul>
<li>Shared rosters, so everyone can see every one else without having to invite them;</li>
<li>Can easily use <a href="https://letsencrypt.org/">Let's encrypt</a> certificates.</li>
</ul>
<p>Note that these features only work if clients support them - so I will also look at clients for various platforms.</p>
<h2>Some background on XMPP</h2>
<p><a href="https://xmpp.org/">XMPP</a>, also known as Jabber, is an extensible protocol. This means that, as well as the core protocol features, you have a number of other features which various servers and clients may or may not implement. These are known as <a href="https://en.wikipedia.org/wiki/XMPP_Standards_Foundation#XEPs">XEPs</a>, and some are relevant only to servers, some only to clients, and some to both.</p>
<p>This can make setting up a server and finding clients with the features you want a little bit complicated at first - but once you know which XEPs you want/need it's fairly easy.</p>
<p>It's also worth noting that multi user chat rooms are fully managed by the client. This means that, on some clients, creating them can seem dauting. In particular chatrooms are handled by a service under a different URL (typically <code>conference.example.com</code>), and some clients expect you to fill this in.</p>
<p>Some other useful terminology:</p>
<ul>
<li><strong>Roster</strong> means list of contacts;</li>
<li><strong>c2s</strong> stands for Client to Server, typically refering services that handle client connections or to the connections themselves;</li>
<li><strong>s2s</strong> stands for Server to Server, typically refering services that handle server connections or to the connections themselves;</li>
<li><strong>virtual hosts</strong> refer to the ability to host multiple domains on one server (people used to setting up web servers will be already familiar with this terminology);</li>
<li>In Prosody, <strong>components</strong> refer to additional services - such as multi user chat rooms - that run on their own URL.</li>
</ul>
<h2>Why Prosody</h2>
<p>I prefer a solution based on open standards, in that case <a href="https://xmpp.org">XMPP</a>, so people can easily use their own client to connect if they already use one. There are chat rooms and messenging software that implement their own interface with their own protocols - I have not looked into those. Amongst the <a href="https://xmpp.org/software/servers.html">available open source XMPP servers</a>, and after a small ammount of research, the four that I have seen recomended are: <a href="https://www.ejabberd.im/">ejabberd</a>, <a href="http://prosody.im/">Prosody</a>, <a href="https://igniterealtime.org/projects/openfire/index.jsp">openfire</a> and <a href="http://www.tigase.net/">tigase</a>.</p>
<p>Openfire and Tigase didn't have Debian packages in Jessie, so I didn't consider them - having a Debian package means I will get security updates as part of my system updates, which is quite important. Having to manually update separate software can be demanding when this is a service you provide in your free time.</p>
<p>Prosody and ejabberd both support my set of requirements. ejabberd has multi-core support, and seems better for larger deploys, while Prosody is said to be more lightweight. I haven't tested these claims - what made the difference for me in the end is that support for <a href="https://xmpp.org/extensions/xep-0363.html">Http file uploads via XEP_0363</a> in ejabberd was not present in the Jessie package. An updated version with http upload support is available as a <a href="https://backports.debian.org/">Debian Backport package</a>, so going for ejabberd would have been an option, but as Prosody covered my requirements I did not see a need for this.</p>
<h2>Installation</h2>
<p>As mentioned, Prosody has a debian package. So installation is as simple as:</p>
<div class="highlight"><pre>    sudo apt-get install prosody prosody-modules
</pre></div>


<h2>Main configuration</h2>
<p>The configuration files are in <code>/etc/prosody</code>, and as per the README in that folder:</p>
<blockquote>
<p>The configuration file /etc/prosody/prosody.cfg.lua should contain only global settings.</p>
<p>Per-host configuration files should be placed in /etc/prosody/conf.avail/, and the active ones should be linked in /etc/prosody/conf.d/</p>
</blockquote>
<p>So in this section I detail the global configuration settings I have applied - those that would apply to all virtual hosts and components.</p>
<p>Note that the configuration file is in <a href="https://en.wikipedia.org/wiki/Lua_(programming_language)">lua</a>, and that lines starting with <code>--</code> are comments.</p>
<p>Here are the items I configured:</p>
<h3>Enable modules</h3>
<p>In the configuration file packaged in Jessie a number of modules are enabled by default. The file is well documented - explaining what each do - so I will only highlight the specific changes I made and things I have found noteworthy.</p>
<p>If you want to check the documentation for a module it's available at <code>https://prosody.im/doc/modules/mod_&lt;module name&gt;</code>; eg. the <code>roster</code> module's documentation is at https://prosody.im/doc/modules/mod_roster .</p>
<p>So things to note:</p>
<ul>
<li>The <a href="https://prosody.im/doc/modules/mod_register">register</a> module, enabled by default, also allows user to change password. You don't need to disable the module to disable registrations - there is a setting for that (see below), so you can leave this module enabled to allow users to change their password without allowing registrations;</li>
<li>The <a href="https://prosody.im/doc/modules/mod_bosh">bosh</a> module is disabled by default. This is needed for some web clients to connect to the server, and as the web client I'm planning to deploy needs it I enabled this module. Note that from version 0.10 (so not the version in Debian Jessie), Prosody also supports websockets, which is an alternative way to allow web clients to connect;</li>
<li>The <a href="https://prosody.im/doc/modules/mod_groups">groups</a> module, which is disabled by default, allows you define shared rosters - that is list of users who can all see each other without having to manually invite each other. This was useful in my use case, so I enabled this;</li>
<li>The <a href="https://prosody.im/doc/modules/mod_auth_internal_hashed">auth_internal_hashed</a> module, which is not in the default configuration file, allows you to keep your user's password in hashed format on the server. There are caveats, as <a href="https://prosody.im/doc/plain_or_hashed">explained in the prosody manual</a>, however I personally feel it is better to used hashed password - in particular as the setup requires encryption, and the clients I expect my users to use support <a href="https://en.wikipedia.org/wiki/Salted_Challenge_Response_Authentication_Mechanism">SCRAM</a>;</li>
<li>The <a href="https://prosody.im/doc/modules/mod_http">http</a> module allows your server to be used as an http server, and is needed for other functionality such as the <a href="https://prosody.im/doc/modules/mod_bosh">bosh</a> module. It actually gets enabled by other modules, however I prefer to have it explicity defined here.</li>
<li>The <a href="https://prosody.im/doc/modules/mod_admin_telnet">admin_telnet</a> module, disabled by default, allows you to control the server and perform various commands. Note that it does not require authentication, so you should only use it if all users on the server are fully trusted - and you should not open your firewall to the port.</li>
</ul>
<p>Modules that are linked to components (for example <a href="http://modules.prosody.im/mod_http_upload">http_upload</a>) can be enabled in the component's declaration - meaning the module is only enabled when the component is, which is useful if you're using links from <code>conf.avail</code> to <code>conf.d</code> as a way to enable/disable components.</p>
<p>The configuration file also includes an area to disable modules that are enabled by default. While I do not need server to server functionality, disabling the <code>s2s</code> module stopped normal chat functionality from working.</p>
<h3>Ensure registration is disabled</h3>
<p>This is default, but best to double check that <code>allow_registration</code> is set to false:</p>
<div class="highlight"><pre><span class="n">allow_registration</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</pre></div>


<h3>Setup SSL/TLS</h3>
<p>I want to make sure all connections use enctryptions. So first, force clients to use encryption:</p>
<div class="highlight"><pre><span class="n">c2s_require_encryption</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div>


<p>While I do not currently enable server to server communication, should I enable it in the future I would also want to force other servers to use encrpytion, with valid certificates. There are some caveats to this approach (which you can read about in the Prosody documentation at http://prosody.im/doc/s2s#security ) but I still prefer to enable this:</p>
<div class="highlight"><pre><span class="n">s2s_secure_auth</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div>


<h3>Use hashed passwords</h3>
<p>As well as enabling the <code>auth_internal_hashed</code> module we need to tell Prosody to use the <code>internal_hashed</code> authentication method:</p>
<div class="highlight"><pre><span class="n">authentication</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">internal_hashed&quot;</span>
</pre></div>


<h3>Configure http server ports</h3>
<p>These are the default values, but I prefer to have them set explicity (so I can just read the configuration file should I forget the port numbers):</p>
<div class="highlight"><pre><span class="n">http_ports</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">5280</span> <span class="p">}</span>
<span class="n">http_interfaces</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;</span><span class="s">*&quot;</span> <span class="p">}</span>

<span class="n">https_ports</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">5281</span> <span class="p">}</span>
<span class="n">https_interfaces</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;</span><span class="s">*&quot;</span> <span class="p">}</span>
</pre></div>


<h3>Setup shared groups</h3>
<p>Shared groups are defined in a single text file. The path to that file should be added to main configuration:</p>
<div class="highlight"><pre><span class="n">groups_file</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">/etc/prosody/sharedgroups.txt&quot;</span>
</pre></div>


<p>The file itself containes sections and list of users, for example:</p>
<div class="highlight"><pre><span class="k">[Everyone]</span>
<span class="err">admin@example.com</span>
<span class="err">user1@example.com</span>
</pre></div>


<h3>Set up virtual host</h3>
<p>Despite the README suggesting to put virtual hosts and components in their own file, there is an example <code>VirtualHost</code> entry in the config file. I commented this one out (using <code>--</code>) then created the file <code>/etc/prosody/conf.avail/example.com.cfg.lua</code> with the following content:</p>
<div class="highlight"><pre><span class="n">VirtualHost</span> <span class="s2">&quot;</span><span class="s">example.com&quot;</span>
        <span class="n">admins</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;</span><span class="s">admin@example.com&quot;</span><span class="p">}</span>
        <span class="n">ssl</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">/etc/prosody/certs/example.com/privkey.pem&quot;</span><span class="p">;</span>
                <span class="n">certificate</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">/etc/prosody/certs/example.com/fullchain.pem&quot;</span><span class="p">;</span>
        <span class="p">}</span>
</pre></div>


<p>Note that the certificates used here don't exist yet - we'll create them later. Also the <code>admin@example.com</code> user doesn't exist yet - we will create that user later.</p>
<p>I then enabled the virtual host by doing:</p>
<div class="highlight"><pre>ln -s /etc/prosody/conf.avail/example.com.cfg.lua /etc/prosody/conf.d/example.com.cfg.lua
</pre></div>


<p>Note that any configuration that follows a <code>VirtualHost</code> (or <code>Component</code>) statement applies only to that virtual host or component, until the next <code>VirtualHost</code> or <code>Component</code> heading is found.</p>
<h3>Setup multi user chat room component</h3>
<p>While components require a URL, they are not linked to a specific virtual host. In my scenario I have a single virtual host so I will use a sub-domain of it for my components. To create the multi user chat room component I added the file <code>/etc/prosody/conf.avail/muc.cfg.lua</code> with the following content:</p>
<div class="highlight"><pre><span class="n">Component</span> <span class="s2">&quot;</span><span class="s">conference.example.com&quot;</span> <span class="s2">&quot;</span><span class="s">muc&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">Chatrooms&quot;</span>
    <span class="n">max_history_message</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">ssl</span> <span class="o">=</span> <span class="p">{</span>
       <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">/etc/prosody/certs/conference.example.com/privatekey.pem&quot;</span><span class="p">;</span>
       <span class="n">certificate</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">/etc/prosody/certs/conference.example.com/fullchain.pem&quot;</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>Where <code>name</code> is the name displayed on discovery messages, and <code>max_history_message</code> the number of history messages sent to clients who just joined the room. And again the certificates don't yet exist. </p>
<p>I then enabled this component host by doing:</p>
<div class="highlight"><pre>ln -s /etc/prosody/conf.avail/muc.cfg.lua /etc/prosody/conf.d/muc.cfg.lua
</pre></div>


<p>If you want external users to use your chatrooms, then you should also ensure you have a DNS entry for <code>conference.example.com</code>. See the <a href="https://prosody.im/doc/chatrooms">Prosody documentation</a> for more information.</p>
<h3>Setup http upload component</h3>
<p>The http upload component allows users to upload files to your servers - which means users can share files on multi user chats (otherwise file sharing is only client to client). To enable this I created the file <code>/etc/prosody/conf.avail/http_upload.cfg.lua</code> with the following content:</p>
<div class="highlight"><pre><span class="n">Component</span> <span class="s2">&quot;</span><span class="s">upload.example.com&quot;</span> <span class="s2">&quot;</span><span class="s">http_upload&quot;</span>
    <span class="n">http_upload_file_size_limit</span> <span class="o">=</span> <span class="mi">5242880</span> 
    <span class="n">http_upload_path</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">/var/lib/prosody/uploads&quot;</span>
</pre></div>


<p>Unfortunately I was not able to get the <code>http_upload</code> component to use it's own ssl certificate - it always picks up the globally defined one. So I set the global <code>ssl</code> setting (in the main config one - not in the Component section) to point to the certificate for <code>upload.example.com</code>:</p>
<div class="highlight"><pre><span class="n">ssl</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">/etc/prosody/certs/upload.example.com/privatekey.pem&quot;</span><span class="p">;</span>
    <span class="n">certificate</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">/etc/prosody/certs/upload.example.com/fullchain.pem&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">I</span> <span class="k">then</span> <span class="n">enabled</span> <span class="n">the</span> <span class="n">component</span> <span class="n">by</span> <span class="n">doing</span><span class="p">:</span>

<span class="err">```</span><span class="n">shell</span>
 <span class="n">ln</span> <span class="o">-</span><span class="n">s</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">prosody</span><span class="o">/</span><span class="n">conf</span><span class="p">.</span><span class="n">avail</span><span class="o">/</span><span class="n">http_upload</span><span class="p">.</span><span class="n">cfg</span><span class="p">.</span><span class="n">lua</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">prosody</span><span class="o">/</span><span class="n">conf</span><span class="p">.</span><span class="n">d</span><span class="o">/</span><span class="n">http_upload</span><span class="p">.</span><span class="n">cfg</span><span class="p">.</span><span class="n">lua</span>
</pre></div>


<p>And created the uploads directory:</p>
<div class="highlight"><pre>mkdir /var/lib/prosody/uploads
chown prosody:prosody /var/lib/prosody/uploads
</pre></div>


<h2>Preparing Let's Encrypt certificates</h2>
<p>Next we will set up security certificates. For this I use <a href="https://letsencrypt.org/">Let's Encrypt</a> which provides free, automated security certificates.</p>
<p>To manage the certificates I use the official client, <a href="https://certbot.eff.org/">cerbot</a>. To install certbot on Debian Jessie you need to do:</p>
<div class="highlight"><pre>sudo apt-get install certbot -t jessie-backports
</pre></div>


<p>We have one virtual host (<code>example.com</code>) and two components (<code>conference.example.com</code> and <code>uploads.example.com</code>) so I will generate a certificate for each of those:</p>
<div class="highlight"><pre>    certbot certonly -d example.com
    cerbot certonly -d conference.example.com
    cerbot certonly -d uploads.example.com
</pre></div>


<p>What exactly happens when you run these commands will depend on what else you have running on your server, and how you want to manage it. I suggest you read the <a href="https://certbot.eff.org/docs/">certbot documentation</a> to find the scenario that applies to your setup.</p>
<p>The folder where Let's Encrypt saves the certificates is not readable by Prosody. As Let's Encrypt renews it's certiciates regularly we should use a script to copy the certificates somewhere Prosody can read them.</p>
<p>Save the following script as <code>/usr/local/sbin/copy-prosody-certs.sh</code>:</p>
<div class="highlight"><pre><span class="ch">#!/bin/bash</span>

<span class="nv">PROSODY_CERTS</span><span class="o">=</span>/etc/prosody/certs
<span class="nv">LE_CERTS</span><span class="o">=</span>/etc/letsencrypt/live
<span class="nv">RELOAD</span><span class="o">=</span>0

<span class="k">for</span> DOMAIN in example.com conference.example.com uploads.example.com
<span class="k">do</span>
    <span class="nv">SOURCE</span><span class="o">=</span><span class="si">${</span><span class="nv">LE_CERTS</span><span class="si">}</span>/<span class="si">${</span><span class="nv">DOMAIN</span><span class="si">}</span>
    <span class="nv">DEST</span><span class="o">=</span><span class="si">${</span><span class="nv">PROSODY_CERTS</span><span class="si">}</span>/<span class="si">${</span><span class="nv">DOMAIN</span><span class="si">}</span>

    mkdir -p <span class="s2">&quot;</span><span class="si">${</span><span class="nv">DEST</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">SOURCE</span><span class="si">}</span><span class="s2">/privkey.pem&quot;</span> -nt <span class="s2">&quot;</span><span class="si">${</span><span class="nv">DEST</span><span class="si">}</span><span class="s2">/privkey.pem&quot;</span> <span class="o">]</span>
    <span class="k">then</span>
        cp <span class="s2">&quot;</span><span class="si">${</span><span class="nv">SOURCE</span><span class="si">}</span><span class="s2">/privkey.pem&quot;</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">DEST</span><span class="si">}</span><span class="s2">&quot;</span>
        cp <span class="s2">&quot;</span><span class="si">${</span><span class="nv">SOURCE</span><span class="si">}</span><span class="s2">/fullchain.pem&quot;</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">DEST</span><span class="si">}</span><span class="s2">&quot;</span>
        chown -R prosody:prosody <span class="s2">&quot;</span><span class="si">${</span><span class="nv">DEST</span><span class="si">}</span><span class="s2">&quot;</span>
        chmod <span class="m">0700</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">DEST</span><span class="si">}</span><span class="s2">&quot;</span>
        chmod <span class="m">0600</span> <span class="si">${</span><span class="nv">DEST</span><span class="si">}</span>/*
        <span class="nv">RELOAD</span><span class="o">=</span>1
    <span class="k">fi</span>
<span class="k">done</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span>$<span class="s2">RELOAD&quot;</span> -eq <span class="m">1</span> <span class="o">]</span>
<span class="k">then</span>
    /usr/bin/prosodyctl reload    
<span class="k">fi</span>
</pre></div>


<p>And make sure it's executable:</p>
<div class="highlight"><pre>chmod <span class="m">0700</span> /usr/local/sbin/copy-prosody-certs.sh
</pre></div>


<p>We will first run the script once to install the certificates:</p>
<div class="highlight"><pre>/usr/local/sbin/copy-prosody/certs.sh
</pre></div>


<p>We also want to make sure the command is run when certificates are renewed. For this we edit <code>/etc/cron.d/certbot</code> to add our script as <code>post-hook</code>:</p>
<div class="highlight"><pre><span class="nv">SHELL</span><span class="o">=</span>/bin/sh
<span class="nv">PATH</span><span class="o">=</span>/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

<span class="m">0</span> */12 * * * root <span class="nb">test</span> -x /usr/bin/certbot -a <span class="se">\!</span> -d /run/systemd/system <span class="o">&amp;&amp;</span> perl -e <span class="s1">&#39;sleep int(rand(3600))&#39;</span> <span class="o">&amp;&amp;</span> certbot -q renew --post-hook /usr/local/sbin/copy-prosody-certs.sh
</pre></div>


<p>And we're done! Note that we could have used <code>--renew-hook</code> with a different script - it's fairly easy to rewrite if you want to.</p>
<h3></h3>
<h2>Final steps, and first connection</h2>
<h3>Create the admin user</h3>
<p>You can create the admin user using the command line tool <code>prosodyctl</code></p>
<div class="highlight"><pre>prosodyctl adduser admin@example.com
</pre></div>


<h3>Open firewall</h3>
<p>And you need to open the firewall! Port <code>5222</code> is the main port, while ports <code>5280</code> and <code>5281</code> are used for the http server:</p>
<div class="highlight"><pre>    iptables -A INPUT -p tcp -m tcp --dport <span class="m">5222</span> -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT
    iptables -A INPUT -p tcp -m tcp --dport <span class="m">5280</span> -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT
    iptables -A INPUT -p tcp -m tcp --dport <span class="m">5281</span> -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT
</pre></div>


<p>Remember to make these changes permanent too, that will depend on how you configured your server (I use <a href="https://packages.debian.org/jessie/iptables-persistent">iptables-persistent</a>.</p>
<h3>Test it!</h3>
<p>Now is time to test, and debug any issues. Start a Jabber/XMPP client, point it to your server, and try connecting with your admin user. If it doesn't work, the logs are in <code>/var/log/prosody</code>.</p>
<p>Once you manage to connect, I'd recomend setting up a second user to test with. And make sure you can't register new accounts (unless you want to allow people to do that!)</p>
<h3>Clients</h3>
            </div>
        </div>
    </div>
        </div>

        <div id="footer">
            <p>Alice online: <a href="http://github.com/aliceh75">GitHub</a> <a href="https://twitter.com/aliceheaton75">Twitter</a></p>
            <p>Site generated by <a href="http://pelican.readthedocs.org">Pelican</a>, theme loosely based on <a href="https://github.com/tbunnyman/pelican-chunk">Chunk</a></p>
            <p>All content by Alice Heaton, licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
               <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
            </p>
        </div>
    </div>
</body>
</html>